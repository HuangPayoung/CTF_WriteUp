64位下elf文件，glibc版本为2.27，有tcache机制。保护机制全开，另外还有沙箱禁止execve系统调用，增删查三大功能，漏洞点在于修改处没有清空指针造成UAF漏洞。

程序分析：
1. 初始化函数，设置输入输入缓冲，另外打开了flag文件，并把打开的fd重定向为666，然后写了一个沙箱函数。
2. bss段上有```int_pt```和```short_pt```两个指针分别用来存储可以申请的两类堆块，还有一个```bool```变量用来标示能否删除堆块。
3. 添加功能，可选择```int```和```short int```两种堆块，其中第一种申请0x30的堆块，第二种申请0x20的堆块，申请的时候没有检查```bool```变量以及存储指针是否为空，申请后由用户输入数字，
存储在数据段偏移为0和偏移为8的位置（刚好是fd和bk的低字节），第一种存4字节，第二种存2字节。
4. 删除功能，首先检查```bool```变量，然后根据用户指定类型以及指针是否存在进行释放，然而没有清空指针，会导致UAF甚至double free的情况。
5. 展示功能，最多能展示3次，根据用户输入类型展示，第一类输出4字节，第二类输出2字节。
6. 退出功能，从标准输入一个字符串，然后拼接一下打印出来。

攻击流程：
1. 构造堆布局，先申请0x30的堆，再申请3个0x20的堆，伪造成一个0x90大小的堆。然后申请一个0x20的堆，double free之后泄露堆地址的低2字节，修改这低2字节使得tcache(0x20)包含指向chunk0头的伪造堆。
2. 利用fake_chunk修改chunk0的size域为0x91，重复释放填满tcache，然后放入unsorted_bin中以泄露libc基址（低4字节）。
3. 使用tcache dup攻击修改libc中```_IO_2_1_stdin_```结构偏移为0x70处的```fileno```变量为666，相比往常tcache dup这里因为不能控制6字节的完整地址，所以要在tcache链上构造两次。
利用unsorted_bin中libc地址，修改低四字节为目标fake_chunk（fileno），这个堆块是从unsorted_bin中切出来的chunk0。
再申请一个0x30的堆，double free后得到一个fd域指向堆块的堆，修改这个fd域指向chunk0，最终依次取出其他堆后就可以得到fake_chunk，并进行修改。
4. 调用退出功能泄露flag。
 
踩坑点：
1. 一开始觉得重定向flag的文件描述符为666，应该是想要调用read函数从这个fd读到某个缓冲区上，然后在调用write函数或者puts函数把缓冲区上的flag打印出来。但是这样做肯定是要控制程序执行流，
并且要知道相关的地址信息才好读到可写的缓冲区上，这两点都很难做到特别是控制程序执行流。后来看其他师傅的博客才意识到退出功能其实有妙用，在前面的攻击流程中先将libc库中```_IO_2_1_stdin_```
结构偏移为0x70处的```fileno```变量修改成666，这样退出功能本来会从标准输入0读入一个字符串拼接，现在变成从666这个flag文件描述符读取flag字符串进行拼接，再打印到标准输出，这样就能泄露flag。
2. 在泄露信息以及添加过程中修改时，是不能像往常一样把整个地址完整泄露出来或者修改的，第一类能读写4字节，第二类能读写2字节。
想要进行tcache dup攻击，要首先在fd域写上相关的地址然后再进行```partial overwrite```。
这里有技巧，要用tcache dup指向特定堆块时，先多次释放使得tcache中堆的fd域指向堆，因为堆的地址范围较小，所以用第二类读写低两字节即可；而libc的范围较大，要获取libc地址，
先想办法将0x90的堆释放7次填满tcache然后再次释放放入unsorted_bin当中（当然用0x410的堆也可以，不需要填满tcache直接进unsorted_bin），然后用第一类读写低四字节。

[参考博客](https://www.cnblogs.com/luoleqi/p/12409143.html)
