64位下堆题增删查改四项功能，保护机制全开，而且还有沙箱，glibc版本为2.27，漏洞点在于删除时没有清空指针导致UAF。

程序分析：
1. 初始化，mmap申请从0x66660000开始共0x1000字节的区域，权限为7（RWX），可以写shellcode到此处执行，因为开了沙箱所以没法拿shell只能ORW。
2. 进入程序主功能，打印菜单然后指定功能，增删查改，总共能使用18次，另外删除功能只能使用3次。
3. 添加功能，指定长度（<= 0x100），tcache范围内的chunk，申请后把指针放到指针列表，把长度放到长度列表
4. 展示功能，指定index，不管长度直接调用puts输出对应指针的内容。
5. 修改功能，指定index，取指针列表和长度列表对应的指针和长度，然后读入改长度，由于删除时会清空长度，所以要double free后再次申请出来，不能直接释放后修改。
6. 删除功能，指定index，释放指针，只清空长度列表没有清空指针列表，导致UAF漏洞。

攻击思路：
1. double free，先泄露堆地址，然后伪造一个fake_chunk指向堆头部，该区域存放tcache的管理结构。
2. 利用整数溢出的漏洞使得tcache链表中0x90大小的结构不可用，然后释放一个0x90大小的chunk放入unsorted_bin，用来泄露libc基址。
3. 修改tcache管理结构中的各个链表，写上0x66660000以及__malloc_hook，然后申请对应大小chunk，往0x66660000写shellcode，往__malloc_hook写0x66660000，申请堆块劫持控制流。

踩坑点：
1. 一开始没注意到mmap以及rwx权限可以写shellcode，不知道从哪下手攻击。
2. 删除总共只能使用3次。一开始我想用tcache dup攻击，先把chunk二次释放放入tcache链表，再申请出来改它的fd域，但是删除次数不够用。
后来参考师傅的博客才发现，其实可以伪造fake_chunk到堆的头部，里面有tcache的管理堆块0x250，里面放着各个tcache的链表。改链表后下次申请tcache范围就会直接从链表取出。

[参考博客](https://blog.csdn.net/github_36788573/article/details/103475238)
