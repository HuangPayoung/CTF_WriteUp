64位arm架构elf文件，仅开启NX保护机制，栈溢出漏洞。

# 攻击思路
1. 往bss段上写mprotect地址和shellcode。
2. 栈溢出后劫持控制流，先调用mprotect函数将shellcode所在地址添加执行权限，然后再跳转执行。

# 小结
1. arm架构下`ret`指令和x86有点不同，是从x30寄存器中取出的，但是没关系，（非叶子）函数返回前会从栈上取返回地址存到x30寄存器，所以栈溢出也是同样的思路。
2. 在上面提到的那一步中，会顺便整理栈帧结构`LDP X29, X30, [SP+0x50+var_50],#0x50`。arm架构不会像x86那样有一条leave指令（因为只有sp寄存器），所以在返回前顺便将栈帧恢复至上一个函数。
3. 64位下，和x86_64类似也存在ret_csu的两段汇编指令，可以控制跳转执行任意函数，不过要提前在内存中的已知位置保存目标函数。

```C=
.text:00000000004008CC loc_4008CC       ; CODE XREF: sub_400868+3C↑j
.text:00000000004008CC   LDP   X19, X20, [SP,#0x10] ; 将sp+0x10处数据给x19，sp+0x18处数据给0x20
.text:00000000004008D0   LDP   X21, X22, [SP,#0x20] ; 将sp+0x20处数据给x21，sp+0x28处数据给0x22
.text:00000000004008D4   LDP   X23, X24, [SP,#0x30] ; 将sp+0x300处数据给x23，sp+0x38处数据给0x24
.text:00000000004008D8   LDP   X29, X30, [SP],#0x40 ; 将sp处数据给x29，sp+0x8处数据给0x30
.text:00000000004008DC   RET   ; 返回x30寄存器中存放的地址

.text:00000000004008AC loc_4008AC       ; CODE XREF: sub_400868+60↓j
.text:00000000004008AC   LDR    X3, [X21,X19,LSL#3] ; 将x21寄存器中的值赋给x3（存放函数地址）
.text:00000000004008B0   MOV    X2, X22 ; 将x22寄存器中的值赋给x2（部署3参）
.text:00000000004008B4   MOV    X1, X23 ; 将x23寄存器中的值赋给x1（部署2参）
.text:00000000004008B8   MOV    W0, W24 ; 将w24寄存器中的值赋给w0（部署1参）
.text:00000000004008BC   ADD    X19, X19, #1 ; x19寄存器中的值加一
.text:00000000004008C0   BLR    X3      ; 跳转至x3寄存器中存放的地址
.text:00000000004008C4   CMP    X19, X20 ; 比较x19寄存器与x20寄存器中的值
.text:00000000004008C8   B.NE   loc_4008AC ; 将x21寄存器中的值赋给x3（存放函数地址）
```

# 参考链接
[参考博客](https://blog.csdn.net/qq_41202237/article/details/118518498?spm=1001.2014.3001.5501)
