64位下堆题，开启NX和canary保护机制，增删改3项功能，glibc版本为2.27有tcache机制。

程序分析：
1. 添加功能用户指定index和size，malloc指定长度后用户输入指定长度，同时将指针与index进行或操作，然后保存在ptr_list中，目的是把index保存在指针数组中。
此处有漏洞，当index指定为16时，会把指针的第5位置1，如果一开始该位置为0就会造成指针被修改，控制好的话可以造成堆叠。
2. 删除功能，用户指定index，然后遍历指针列表，将指针与0xf作与操作以获取index，此处无法处理index为16，只会当做index为0。然后清空指针和长度，无UAF漏洞。
3. 修改功能，同删除一样获取index，然后输入指定的长度。

攻击思路：
1. 构造堆布局，chunk0指定index为16，并在数据区伪造一个0x31作为size域，然后再申请一个chunk1，先释放chunk1再释放chunk0造成堆叠。
2. 利用堆叠修改chunk1的fd域，进行tcache_dup攻击，伪造堆块至ptr_list处，然后写上got表，利用got表中函数完成泄露和攻击。
