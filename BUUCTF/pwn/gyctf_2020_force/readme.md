64位下堆题，仅有添加一个功能，在添加的时候不管申请堆块大小，始终读取0x50字节，这里可能造成堆溢出。

攻击方法：house_of_force，修改top_chunk的大小，使得后续能够随意申请非常大的堆块。

1. 申请0x200000大小的堆块，足够大会采用mmap方式申请，这个区域和libc基址有固定偏移，可以用来泄露libc基址。

2. 申请0x18大小堆块，利用溢出覆盖top_chunk大小，然后将top_chunk申请至__malloc_hook之前一定偏移的区域，以便下一次能够申请到__malloc_hook处的堆块。

3. 申请0x20大小的堆块，经过调试发现直接在__malloc_hook写one_gadget都不能实现攻击，原因是栈上的环境不符合，所以要用到之前学的，用realloc的片段来调整栈布局。

这里有一个小技巧，realloc的调用过程是先push6个寄存器的值到栈上，然后rsp-0x38，call的时候又会压返回地址到栈上，然后调用写在__realloc_hook处的one_gadget
（libc-2.23.so的情况，其他版本可能有所不同），所以在第一次调试的时候，先不要跳到realloc后面的几条指令，直接从头开始执行，例如在本题中就有寄存器的值为0然后压到栈上，
然后配合几个one_gadget的约束条件，看看要跳到哪条指令开始执行刚好能够满足。

[参考博客](https://blog.csdn.net/weixin_44145820/article/details/105522043)
